\documentclass[preview,multi,crop=false,border=1in,class=memoir]{standalone}
\usepackage{../common}

\begin{document}
\begin{preview-page}
\section{函数}

函数是Erlang里最基本的概念之一。其实，算术运算也会先转换成函数调用再计
算。比如，初识Erlang中最开始的例子可以写成下面这样。

\begin{ErlangShellSession}
1> erlang:'+'(1,1).
2
2> erlang:'-'(5,2).
3
3> erlang:'*'(2,2).
4
4> erlang:'+'(1,erlang:'*'(2,2)).
5
5> erlang:'*'(erlang:'+'(1,2),2).
6
6>
\end{ErlangShellSession}


现在就来看一下怎么解释函数。


\subsection{Environment}

函数中定义的变量，在调用的过程中，会有对应的值。比如，



把这种对应关系称为Environment。要解释函数，就要能表示Environment。方便起见，
这里先用小写字母开头的 \verb|atom()| 来代表变量名。

\begin{Exercise}[title={environ},difficulty=2]
在 \verb|environ| 模块里定义四个函数，\verb|empty/0|, \verb|is_bound/2|,
\verb|bind/3|, \verb|get_value/2|。

调用 \verb|empty/0| 可以得到一个空的Environment。\verb|is_bound/2| 用来
检查变量名是否在Environment里有定义。\verb|bind/3| 用来把变量名和值关联
起来。\verb|get_value/2| 用来获取变量的值。

% SNIP REFERENCE exercise.erl ex-environ
\begin{SourceCode}
% SNIP BEGIN ex-environ
check(environ) ->
    Env = environ:empty(),
    false = environ:is_bound(a, Env),
    Env1 = environ:bind(a, b, Env),
    true = environ:is_bound(a, Env1),
    b = environ:get_value(a, Env1),
    ok;
% SNIP END
\end{SourceCode}
\end{Exercise}

\begin{Answer}

% SNIP REFERENCE environ.erl ans-environ
\begin{SourceCode}
% SNIP BEGIN ans-environ
empty() ->
    [].

bind(Name, Value, Env) ->
    [{Name,Value}|Env].

is_bound(_, []) ->
    false;
is_bound(Name, [{Name, _}|_]) ->
    true;
is_bound(Name, [_|Env]) ->
    is_bound(Name, Env).

get_value(Name, [{Name, Value}|_]) ->
    Value;
get_value(Name, [_|Env]) ->
    get_value(Name, Env).
% SNIP END
\end{SourceCode}
\end{Answer}

\nonzeroparskip

现在用一个特殊的 \verb|list()| 来表示Environment。这个 \verb|list()| 的
每个元素都是一个特殊的 \verb|tuple()| 。这个 \verb|tuple()| 的第一个元
素用来表示变量名，第二个元素用来表示变量的值。定义 \verb|subst/2| ，用
来从这样的Environment里取出变量的值。

% SNIP REFERENCE func_quote.erl func-subst
\begin{SourceCode}
% SNIP BEGIN func-subst
subst(_, []) ->
    none;
subst(K, [{K, V}|_]) ->
    {ok, V};
subst(K, [_|T]) ->
    subst(K, T).
% SNIP END
\end{SourceCode}


\subsection{S表达式}

定义S表达式 \cite{McCarthy:1960:symbolic}

\begin{itemize}
\item 若 \verb|Expr| 是一个 \verb|atom()| ， \verb|Expr| 是一个S表达式。
\item 若 \verb|Expr| 是一个 \verb|list()| ，且 \verb|Expr| 里的所有元素
都是S表达式，那么 \verb|Expr| 是一个S表达式。
\end{itemize}

\begin{Exercise}[title={sexpr},difficulty=1]
在 \verb|sexpr| 模块里定义 \verb|is_sexpr/1| 函数，判断是否是S表达式。

% SNIP REFERENCE exercise.erl ex-sexpr
\begin{SourceCode}
% SNIP BEGIN ex-sexpr
check(sexpr) ->
    true = sexpr:is_sexpr(a),
    false = sexpr:is_sexpr(1),
    true = sexpr:is_sexpr([]),
    true = sexpr:is_sexpr([a]),
    true = sexpr:is_sexpr([a, b, c]),
    false = sexpr:is_sexpr([1]),
    false = sexpr:is_sexpr([{a,a}]),
    ok;
% SNIP END
\end{SourceCode}
\end{Exercise}

\begin{Answer}

% SNIP REFERENCE sexpr.erl ans-sexpr
\begin{SourceCode}
% SNIP BEGIN ans-sexpr
is_sexpr([]) ->
    true;
is_sexpr([Head|Tail]) ->
    case is_sexpr(Head) of
        false ->
            false;
        true ->
            is_sexpr(Tail)
    end;
is_sexpr(Expr) ->
    is_atom(Expr).
% SNIP END
\end{SourceCode}
\end{Answer}

\nonzeroparskip

若S表达式是一个 \verb|atom()| ，将其视为变量名，其值可以在Environment中
找到。若一个S表达式是一个 \verb|list()| ，我们把它当作是一个函数调用，
其中，这个 \verb|list()| 第一个元素的值，是被调用的函数，剩余的元素就是
传入的参数。这种求值的规则可以用 \verb|apply/2| 来表示。
\verb|apply/2| 定义如下

% SNIP REFERENCE func_quote.erl func-apply
\begin{SourceCode}
% SNIP BEGIN func-apply
apply([H|T], Env) ->
    {Fun, Env1} = apply(H, Env),
    call(Fun, T, Env1);
apply(Expr, Env) ->
    true = is_atom(Expr),
    {ok, Value} = subst(Expr, Env),
    {Value, Env}.
% SNIP END
\end{SourceCode}

注意，Erlang编译时默认导入的函数中，也有叫 \verb|apply/2| 的。可以在文
件开头取消。

% SNIP REFERENCE func_quote.erl func-no-auto-import
\begin{SourceCode}
% SNIP BEGIN func-no-auto-import
-compile({no_auto_import, [apply/2]}).
% SNIP END
\end{SourceCode}

因为现在普通的数据和函数都是从同一个Environment里取出来的，为了区分，用
\verb|{data, X}| 表示普通数据， 用 \verb|{fn, X}| 表示函数。光有一个空
的Environment和求值规则，啥也做不了。接下来就来定义一些基本函数。

\subsection{quote}

假如，我们想让一个表达式的求值结果是一个 \verb|atom()| ，比如 \verb|a|
。因为在求值过程中， 一个 \verb|atom()| 会当作变量名，直接对 \verb|a|
求值得到的会是变量 \verb|a| 的值，而不是 \verb|a| 。为了能得到
\verb|a| ，需要定义 \verb|quote| 函数。这个函数只接受一个参数，调用这个
函数的结果就是传入的参数。

% SNIP REFERENCE func_quote.erl func-test-quote1
\begin{SourceCode}
% SNIP BEGIN func-test-quote1
test(quote) ->
    {{data, a}, _} =
        apply([quote, a], new_env()),
    {{data, [a,b,c]}, _} =
        apply([quote, [a,b,c]], new_env())
% SNIP END
.
\end{SourceCode}

先定义\verb|new_env/0| ，用来得到一开始的 Environment。

% SNIP REFERENCE func_quote.erl func-env-quote
\begin{SourceCode}
% SNIP BEGIN func-env-quote
new_env() ->
    [{quote, {fn, quote}}
%- SNIP END
].
\end{SourceCode}

\verb|quote| 的定义很简单。

% SNIP REFERENCE func_quote.erl func-quote
\begin{SourceCode}
% SNIP BEGIN func-quote
call({fn, quote}, [X], Env) ->
    {{data, X}, Env}
%- SNIP END
.
\end{SourceCode}

S表达式的 \verb|[quote, a]| 作用相当于 Erlang 里的 \verb|a| 。这已经不
是一般的函数了，不过这里仍然把它称作函数。在Erlang里调用一个函数前，会
先对各个参数的表达式求值。定义 \verb|id/1| 函数

% SNIP REFERENCE equiv.erl func-equiv-id
\begin{SourceCode}
% SNIP BEGIN func-equiv-id
id(X) ->
    X.
% SNIP END
\end{SourceCode}

不难看出

% SNIP REFERENCE equiv.erl func-test-equiv-id
\begin{SourceCode}
% SNIP BEGIN func-test-equiv-id
test(id) ->
    a = id(a),
    a = id(id(a));
% SNIP END
\end{SourceCode}

而在S表达式里，在调用函数前，没有先对表达式求值。所以，
\verb|[quote, [quote, a]]| 的求值结果会是 \verb|[quote, a]| 。

% SNIP REFERENCE func_quote2.erl func-test-quote2
\begin{SourceCode}
% SNIP BEGIN func-test-quote2
    {{data, [quote, a]}, _} =
        apply([quote, [quote, a]], new_env())
% SNIP END
.
\end{SourceCode}


\begin{Exercise}[title={id},difficulty=1]
定义S表达式函数 \verb|id| ，使其和Erlang里 \verb|id/1| 有相同的作用

% SNIP REFERENCE exercise.erl ex-id
\begin{SourceCode}
% SNIP BEGIN ex-id
check(id) ->
    {{data, a}, _} =
        func_id:apply([id, [quote, a]], func_id:new_env()),
    {{data, a}, _} =
        func_id:apply([id, [id, [quote, a]]], func_id:new_env()),
    ok;
% SNIP END
\end{SourceCode}

\end{Exercise}

\begin{Answer}

% SNIP REFERENCE func_id.erl ans-id-func
\begin{SourceCode}
% SNIP BEGIN ans-id-func
call({fn, id}, [X], Env) ->
    apply(X, Env).
% SNIP END
\end{SourceCode}

% SNIP REFERENCE func_id.erl ans-id-newenv
\begin{SourceCode}
% SNIP BEGIN ans-id-newenv
     {id,    {fn, id}}].
% SNIP END
\end{SourceCode}

\end{Answer}


\subsection{label}

定义一个S表达式函数 \verb|label| ，用来指定变量的值。现在不考虑模式，只
要做到和Erlang里 \verb|X = a| 类似就行了。因为要检查后面的表达式里变量
的值， 在定义 \verb|label| 之前，先定义一个辅助函数\verb|eval_list/2|
，用来对一连串S表达式分别求值。


% SNIP REFERENCE func_label.erl func-eval-list
\begin{SourceCode}
% SNIP BEGIN func-eval-list
eval_list([], Env) ->
    {[], Env};
eval_list([H|T], Env) ->
    {VH, Env1} = apply(H, Env),
    {VT, Env2} = eval_list(T, Env1),
    {[VH|VT], Env2}.
% SNIP END
\end{SourceCode}

接着来定义 \verb|label|

% SNIP REFERENCE func_label.erl func-label
\begin{SourceCode}
% SNIP BEGIN func-label
call({fn, label}, [X,Y], Env) ->
    {Y1, Env1} = apply(Y, Env),
    {Y1, [{X, Y1}|Env1]}
%- SNIP END
.
\end{SourceCode}

这样定义的问题是，前一次指定的值会被后一次指定的值覆盖

% SNIP REFERENCE func_label.erl func-test-label
\begin{SourceCode}
% SNIP BEGIN func-test-label
test(label) ->
    {[{data, a}, {data, a}], _} =
        eval_list([[label, x, [quote, a]],
                   x
                  ], new_env()),
    {[{data, b}, {data, b}], _} =
        eval_list([[label, x, [quote, b]],
                   x
                  ], new_env()),
    {[{data, a}, {data, b}, {data, b}], _} =
        eval_list([[label, x, [quote, a]],
                   [label, x, [quote, b]],
                   x
                  ], new_env())
%- SNIP END
.
\end{SourceCode}

而在Erlang里，这样会导致出错

\begin{ErlangShellSession}
1> X = a.
a
2> X = b.
** exception error: no match of right hand side value b
3>
\end{ErlangShellSession}

不过，这实际上是模式匹配的作用。这里就先保留当前的定义，小心一点不重复
指定同一个变量的值就好了。

\subsection{car, cdr, cons}

因为S表达式由 \verb|list()| 和 \verb|atom()| 组成，所以肯定要定义一些
\verb|list()| 相关的函数。 \verb|car|, \verb|cdr|, \verb|cons| 分别对应
Erlang里的 \verb|car/1|, \verb|cdr/1| 和 \verb|cons/2| 。

% SNIP REFERENCE equiv.erl func-equiv-list
\begin{SourceCode}
% SNIP BEGIN func-equiv-list
car([H|_]) -> H.
cdr([_|T]) -> T.
cons(H, T) -> [H|T].
% SNIP END
\end{SourceCode}

\verb|car/1| 用来取出一个 \verb|list()| 的第一个元素

% SNIP REFERENCE equiv.erl func-test-equiv-car
\begin{SourceCode}
% SNIP BEGIN func-test-equiv-car
test(car) ->
    a = car([a]),
    a = car([a,b]);
% SNIP END
\end{SourceCode}

\verb|cdr/1| 用来取出一个 \verb|list()| 的除第一个元素以外的所有元素

% SNIP REFERENCE equiv.erl func-test-equiv-cdr
\begin{SourceCode}
% SNIP BEGIN func-test-equiv-cdr
test(cdr) ->
    [] = cdr([a]),
    [b] = cdr([a,b]);
% SNIP END
\end{SourceCode}

\verb|cons/2| 用来在一个 \verb|list()| 之前加上一个元素。

% SNIP REFERENCE equiv.erl func-test-equiv-cons
\begin{SourceCode}
% SNIP BEGIN func-test-equiv-cons
test(cons) ->
    [a] = cons(a, []),
    [a,b] = cons(a, [b]).
% SNIP END
\end{SourceCode}

定义 \verb|car|, \verb|cdr|, \verb|cons| 。

% SNIP REFERENCE func_list.erl func-list
\begin{SourceCode}
% SNIP BEGIN func-list
call({fn, car}, [X], Env) ->
    {{data, [H|_]}, Env1} = apply(X, Env),
    {{data, H}, Env1};
call({fn, cdr}, [X], Env) ->
    {{data, [_|T]}, Env1} = apply(X, Env),
    {{data, T}, Env1};
call({fn, cons}, [X,Y], Env) ->
    {[{data,X1}, {data,Y1}], Env1} =
        eval_list([X,Y], Env),
    {{data, [X1|Y1]}, Env1}
%- SNIP END
.
\end{SourceCode}

可以看到和Erlang里对应的函数作用是一样的。

% SNIP REFERENCE func_list.erl func-test-list
\begin{SourceCode}
% SNIP BEGIN func-test-list
test(list) ->
    {{data, a}, _} =
        apply([car, [quote, [a]]], new_env()),
    {{data, a}, _} =
        apply([car, [quote, [a,b]]], new_env()),
    {{data, []}, _} =
        apply([cdr, [quote, [a]]], new_env()),
    {{data, [b]}, _} =
        apply([cdr, [quote, [a,b]]], new_env()),
    {{data, [a]}, _} =
        apply([cons, [quote, a], [quote, []]],
              new_env()),
    {{data, [a,b]}, _} =
        apply([cons, [quote, a], [quote, [b]]],
              new_env())
%- SNIP END
.
\end{SourceCode}

\subsection{cond}

Erlang里，一个函数可以有多个分句。这也可以用case表达式来表示。因为不考
虑模式，所以这里定义的 \verb|cond| 就相当于只剩下guard的case表达式。 函
数 \verb|cond| 只接受一个 \verb|list()| 类型的参数，其中每个元素都是一
个有两个元素的 \verb|list()| 。逐个对其第一个元素求值，直到找到一个
\verb|list()| ，对其第一个元素求值的结果是 \verb|true| ，那么调用
\verb|cond| 函数的结果就是对其第二个元素求值的结果。


% SNIP REFERENCE func_cond.erl func-test-cond
\begin{SourceCode}
% SNIP BEGIN func-test-cond
test('cond') ->
    {{data, a}, _} =
        apply(['cond',
               [[quote, true],  [quote, a]],
               [[quote, false], [quote, b]],
               [[quote, false], [quote, c]]
              ], new_env()),
    {{data, b}, _} =
        apply(['cond',
               [[quote, false], [quote, a]],
               [[quote, true],  [quote, b]],
               [[quote, false], [quote, c]]
              ], new_env()),
    {{data, c}, _} =
        apply(['cond',
               [[quote, false], [quote, a]],
               [[quote, false], [quote, b]],
               [[quote, true],  [quote, c]]
              ], new_env())
%- SNIP END
.
\end{SourceCode}

以下是 \verb|cond| 的定义

% SNIP REFERENCE func_cond.erl func-cond
\begin{SourceCode}
% SNIP BEGIN func-cond
call({fn, 'cond'}, [[P,E]|T], Env) ->
    {{data, R}, Env1} = apply(P, Env),
    case R of
        false ->
            apply(['cond'|T], Env1);
        true ->
            apply(E, Env1)
    end
%- SNIP END func-cond
.
\end{SourceCode}

\subsection{atom, eq}

光有这样的 \verb|cond| 并没有什么用，还需要定义一些函数能对值进行一些判
断。先来看 \verb|atom| 。 \verb|atom| 的作用和Erlang里
\verb|is_atom/1| 一样。


% SNIP REFERENCE func_pred.erl func-test-atom
\begin{SourceCode}
% SNIP BEGIN func-test-atom
test(atom) ->
    {{data, true}, _} =
        apply([atom, [quote, a]], new_env()),
    {{data, false}, _} =
        apply([atom, [quote, [a,b,c]]], new_env());
% SNIP END
\end{SourceCode}

\verb|atom| 的定义很简单。

% SNIP REFERENCE func_pred.erl func-atom
\begin{SourceCode}
% SNIP BEGIN func-atom
call({fn, atom}, [X], Env) ->
    {{data, X1}, Env1} = apply(X, Env),
    {{data, is_atom(X1)}, Env1};
% SNIP END
\end{SourceCode}

再来看 \verb|eq| 。 \verb|eq| 用来比较两个值是否相同。不过有个例外，对
于两个非空的 \verb|list()| ，即便所有元素都相同，在这里也认为不同。因为
能判断的话，已经具有部分模式匹配的功能了，这是现在需要尽量避免的。

% SNIP REFERENCE func_pred.erl func-test-eq
\begin{SourceCode}
% SNIP BEGIN func-test-eq
test(eq) ->
    {{data, true}, _} =
        apply([eq, [quote, []], [quote, []]],
              new_env()),
    {{data, true}, _} =
        apply([eq, [quote, a], [quote, a]],
              new_env()),
    {{data, false}, _} =
        apply([eq, [quote, []], [quote, a]],
              new_env()),
    {{data, false}, _} =
        apply([eq, [quote, a], [quote, []]],
              new_env()),
    {{data, false}, _} =
        apply([eq, [quote, [a]], [quote, [b]]],
              new_env()),
    {{data, false}, _} =
        apply([eq, [quote, [a,b,c]], [quote, [a,b,c]]],
              new_env())
%- SNIP END
.
\end{SourceCode}

在Erlang里，可以用 \verb|eq/2| 表示

% SNIP REFERENCE func_pred.erl func-helper-eq
\begin{SourceCode}
% SNIP BEGIN func-helper-eq
eq([], []) ->
    true;
eq(X, Y)
  when is_atom(X), is_atom(Y) ->
    X =:= Y;
eq(_, _) ->
    false.
% SNIP END
\end{SourceCode}


直接用一下Erlang里的 \verb|eq/2| 就定义出 \verb|eq| 来了。

% SNIP REFERENCE func_pred.erl func-eq
\begin{SourceCode}
% SNIP BEGIN func-eq
call({fn, eq}, [X,Y], Env) ->
    {[{data,X1}, {data,Y1}], Env1} =
        eval_list([X,Y], Env),
    {{data, eq(X1,Y1)}, Env1}
%- SNIP END
.
\end{SourceCode}

\subsection{lambda}

可以用 \verb|lambda| 定义函数。 \verb|lambda| 的第一个参数是函数的参数列表，第二个参数是一个S表达式。

% SNIP REFERENCE func_lambda.erl func-test-lambda
\begin{SourceCode}
% SNIP BEGIN func-test-lambda
test(lambda) ->
    {{data, a}, _} =
        apply([[lambda, [x], x],
               [quote, a]], new_env()),
    {{data, a}, _} =
        apply([[lambda, [x], [car, x]],
               [quote, [a,b,c]]], new_env()),
    {{data, a}, _} =
        apply([[lambda, [x], [car, [car, x]]],
               [quote, [[a]]]], new_env()),
    {{data, true}, _} =
        apply([[lambda, [x, y], [eq, x, y]],
               [quote, a],
               [quote, a]], new_env()),
    {{data, a}, _} =
        apply([[lambda, [x, x], x],
               [quote, a],
               [quote, b]], new_env())
%- SNIP END
.
\end{SourceCode}


% SNIP REFERENCE func_lambda.erl func-lambda
\begin{SourceCode}
% SNIP BEGIN func-lambda
call({fn, lambda}, [P,E], Env) ->
    {{lambda, {P,E}}, Env};
call({lambda, {P,E}}, Args, Env) ->
    {Args1, Env1} = eval_list(Args, Env),
    {V, _} = apply(E, append(zip(P, Args1), Env1)),
    {V, Env1}
%- SNIP END
.
\end{SourceCode}


\subsection{macro}

\begin{Exercise}[title={defun},difficulty=1]
\verb|[defun, N, P, E]| 表示 \verb|[label, N, [lambda, P, E]]|\cite{Graham:2001:roots}。

定义S表达式函数 \verb|defun|

% SNIP REFERENCE exercise.erl ex-defun
\begin{SourceCode}
% SNIP BEGIN ex-defun
check(defun) ->
    {[_,{data, a}], _} =
        defun:eval_list(
          [[defun, caar, [x], [car, [car, x]]],
           [caar, [quote, [[a]]]]], defun:new_env()).
% SNIP END
\end{SourceCode}

\end{Exercise}

\begin{Answer}

% SNIP REFERENCE defun.erl ans-defun
\begin{SourceCode}
% SNIP BEGIN ans-defun
call({fn, defun}, [N,P,E], Env) ->
    apply([label, N, [lambda, P, E]], Env).
% SNIP END
\end{SourceCode}
\end{Answer}

\verb|macro|

% SNIP REFERENCE func_macro.erl func-test-macro
\begin{SourceCode}
% SNIP BEGIN func-test-macro
test(macro) ->
    {[_,_,{data, a}], _} =
        eval_list(
          [[label, defun,
            [macro, [n,p,e],
             [ cons, [quote, label],
              [cons, n,
              [cons, [ cons, [quote, lambda],
                      [cons, p,
                      [cons, e,
                             [quote, []]
                      ]]],
                     [quote, []]
              ]]]
            ]
           ],
           [defun, caar, [x], [car, [car, x]]],
           [caar, [quote, [[a]]]]
          ], new_env()).
% SNIP END
\end{SourceCode}

% SNIP REFERENCE func_macro.erl func-macro
\begin{SourceCode}
% SNIP BEGIN func-macro
call({fn, macro}, [P,E], Env) ->
    {{macro, {P,E}}, Env};
call({macro, {P,E}}, Args, Env) ->
    Env1 = append(zip(P, quote_list(Args)), Env),
    {{data, E1}, _} = apply(E, Env1),
    apply(E1, Env).
% SNIP END
\end{SourceCode}


\end{preview-page}
\end{document}
